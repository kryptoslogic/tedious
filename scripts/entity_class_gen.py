#!/usr/bin/python3

"""
JANKY CODE ALERT

This script parses the builtin entity metadata, and uses them to construct Python
classes fur further use/analysis. This also lets documentation get auto-generated,
which is kinda neat.

Not particularly useful yet.

Note: if you export your custom entities from the Malgego UI, you can process
them with this script by setting ENTITY_JAR to point at it
"""

import zipfile
import xml.etree.ElementTree as ET
import os
import glob
import argparse

JAR_PATH = "/usr/share/maltego"
OUTDIR = "../tedious/entities"
OUTDIR = os.path.join(os.path.dirname(os.path.realpath(__file__)), OUTDIR) # relative to path of this script


def normalise_name(name):
	return name.lower().replace(".", "_").replace("-", "_")


# how many layers of metaprogramming are you on right now?
# watch this
def build_class_declaration(xml, namespace, name):
	s = ""
	s += "# The contents of this file have been autogenerated. Edit at your own risk!!!\n"
	s += "# Despite this, it *is* intended to be human readable.\n"
	s += '\n"""\n.. highlight:: xml\n.. code-block:: xml\n\n\t{}\n\n"""\n\n'.format(ET.tostring(xml).decode().replace("\n", "\n\t"))
	
	s += "import tedious.entities as entities\n"
	baseentity = xml.find("BaseEntities/BaseEntity")
	if baseentity is not None:
		baseid = baseentity.text
		basename = baseid.split(".")[-1]
		s += "from tedious.entities.{} import {}\n".format(baseid, basename)
		baseclass = basename
	else:
		baseclass = "entities.MaltegoEntity"
	
	s += "\nclass {}({}):\n".format(name, baseclass)
	s += '\t"""\n\t{}\n\t"""\n\n'.format(xml.attrib.get("description"))
	for attr in ["id", "displayName", "displayNamePlural"]:
		s += "\t{} = {}\n".format(attr, repr(xml.attrib.get(attr)))
	
	fields = {} # XXX: does not preserve order!!!
	for field in xml.findall("Properties/Fields/Field"):
		pyname = normalise_name(field.attrib["name"])
		fields[pyname] = {k: field.attrib[k] for k in ["name", "type", "nullable"]}
	
	s += "\n"
	
	for field, properties in fields.items():
		s += "\t{} = None # {} {}\n".format(field, properties["type"], properties["name"])
	
	# _fields metadata is used for XML marshaling
	s += "\n\t_fields = {\n"
	for k, v in fields.items():
		s += "\t\t{}: {},\n".format(repr(k), v)
	s += "\t}\n\n"
	
	initialisers = "foo"
	s += "\tdef __init__(self, value, {}):\n".format(", ".join([fname + "=None" for fname in fields.keys()]+["**kwargs"]))
	s += "\t\tsuper().__init__(value, **kwargs)\n"
	for field, properties in fields.items():
		s += "\t\tself.{0} = {0}\n".format(field)
	
	s += "\nentities.entity_map[{0}.id] = {0}\n".format(name)
	
	return s




def resolve_dependency_order(entities):
	def preorder_traversal(child_entity, root_id): # is it bad style to have an internal function like this?
		res = child_entity[root_id].copy()
		for child_id in child_entity[root_id]:
			res += preorder_traversal(child_entity, child_id)
		return res
	
	child_entity = {None:[]}
	entities_by_id = {}
	for entity in entities:
		this = entity.attrib["id"]
		entities_by_id[this] = entity
		child_entity[this] = []
	
	# construct dependency tree
	for entity in entities:
		this = entity.attrib["id"]
		baseentity = entity.find("BaseEntities/BaseEntity")
		parent = baseentity.text if (baseentity is not None) else None
		if parent not in entities_by_id: # XXX: this should be a proper check for entities in a parent namespace
			parent = None
		child_entity[parent].append(this)
	
	order = preorder_traversal(child_entity, None)
	return [entities_by_id[id] for id in order]

parser = argparse.ArgumentParser(description="Maltego .entity parser/Python class generator")
parser.add_argument("--mtz", help="Path to the exported .MTZ file containing entities")
args = parser.parse_args()

entities = dict()

if args.mtz:
	files = [args.mtz,]
else:
	files = glob.iglob(JAR_PATH + "/**/*.jar", recursive=True)

# load the entities into a dict, indexed by id
for f in files:
	jar = zipfile.ZipFile(f)
	for filename in jar.namelist():
		if not filename.endswith(".entity"):
			continue
		entity_xml = ET.fromstring(jar.open(filename).read())
		if entity_xml.attrib.get("id"):
			entities[entity_xml.attrib["id"]] = entity_xml
	jar.close()

modules = {}

# rearrange the entities by namespace
for entity_id, xml in entities.items():
	*namespace, name = entity_id.split(".")
	namespace = tuple(namespace)
	if namespace not in modules:
		modules[namespace] = []
	modules[namespace].append(xml)

# iterate thru all namespaces
for namespace, entities in modules.items():
	os.makedirs(os.path.join(OUTDIR, *namespace), exist_ok=True)
	initpath = os.path.join(OUTDIR, *namespace, "__init__.py")
	with open(initpath, "w") as initfile:
		# iterate thru all entities
		for xml in resolve_dependency_order(entities):
			name = xml.attrib["id"].split(".")[-1]
			initfile.write("from .{0} import {0}\n".format(name))
			filename = name + ".py"
			with open(os.path.join(OUTDIR, *namespace, filename), "w") as classfile:
				classfile.write(build_class_declaration(xml, namespace, name))
		
		initfile.write("\n")
		
		# lazy scan for submodules:
		for n in modules.keys():
			if list(namespace) == list(n)[:-1]: # are we an immediate parent of this other namespace?
				initfile.write("from . import {}\n".format(n[-1]))
